# 배열

알고리즘 문제 해결을 위한 도구

## 자료구조

- 데이터를 효율적으로 담는 방법을 정의한 것
    - 데이터의 추가, 조회, 수정, 삭제 연산을 최적화 하는 구조
- 프로그램의 목적에 따라 활용할 수 있는 다양한 자료구조가 존재
- 효율적인 알고리즘을 구현하기 위해서는 효율적인 자료구조가 필수적

## 배열

자료구조로서의 배열 | 문제 해결을 위한 도구

- 동일한 자료형의 변수들을 하나의 변수에 담기 위한 자료구조

### 배열의 필요성

- 프로그램 내에서 여러 개의 데이터를 다루어야 할 때, 별도의 변수를 선언하여 프로그래밍을 하는 것은 비효율적 → 배열을 사용하면 효율적으로 사용할 수 있음

### 1차원 배열의 선언

`int[] nums = new int[6];`  |  `int[] arr = {3, 1, 2, 4};` 

- 자료형 : 배열을 이루는 자료형
- 이름 : 프로그램에서 사용할 배열의 이름
- 길이 : 배열을 이루는 원소의 수

### 1차원 배열의 접근

`nums[0] = 10;`  // 배열의 nums의 0번째 원소에 10을 저장

`nums[idx] = 20;`  // 배열 nums의 idx번째 원소에 20을 저장

### APS를 위한 5단계

1. 문제를 꼼꼼하게 읽고 **입력 데이터의 범위를 확인**
2. 문제의 조건과 입력 데이터의 범위에 맞는 알고리즘 선택
3. 코드를 작성하기 전에 풀이를 구상
4. 구상한 풀이를 코드로 작성
5. 디버깅하고 검증

## 2차원 배열

1차원 배열들을 담을 수 있는 배열 → JVM `heap` 영역에서 관리

### 2차원 배열의 선언

`int[][] twoDimArr = new int[2][4]`  → 2행 4열의 2차원 배열 선언

`int[][] arr = new int[필수][]`

⇒ 세로 길이(행의 개수), 가로 길이(열의 개수)를 필요로 함

- N차원 배열일 때 N-1차원 배열의 길이는 달라질 수 있음

## 2차원 배열의 접근

### 배열 순회

- n x m 배열의 n*m 개의 모든 원소를 빠짐없이 조사하는 방법
- 행 우선 순회
    
    ```java
    int[][] arr = new int[n][m];
    
    int row; // 행의 좌표
    int col; // 열의 좌표
    
    for row from 0 to n-1
    	for col from 0 to m-1
    		Array[row][col]; // 필요한 연산 수행
    ```
    
- 열 우선 순회
    
    ```java
    int[][] arr = new int[n][m];
    
    int row; // 행의 좌표
    int col; // 열의 좌표
    
    for col from 0 to m-1
    	for row from 0 to n-1
    		Array[row][col]; // 필요한 연산 수행
    ```
    
- 지그재그 순회
    
    ```java
    int[][] arr = new int[n][m];
    
    int row; // 행의 좌표
    int col; // 열의 좌표
    
    for row from 0 to n-1
    	for col from 0 to m-1
    		Array[row][col+(m-1-2*col)*(row%2)]
    		=>Array[row][(i%2 != 0) ? col : m-1-col]
    
    if ( i%2 != 0 ){ // 홀수행일때
    for 오름차순 순회
    } else {
    for 내림차순 순회
    }
    ```
    

### 델타를 이용한 2차원 배열 탐색

델타 배열 : 이동 후의 좌표 차이를 저장해 둔 배열

|  | 상[0] | 하[1] | 좌[2] | 우[3] | 우상 | 우하 | 좌상 | 좌하 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| row | -1 | 1 | 0 | 0 | -1 | 1 | 1 | -1 |
| col | 0 | 0 | -1 | 1 | 1 | 1 | -1 | -1 |

(r, c) 좌표에서 오른쪽으로 한 칸 이동 ⇒ (r+0)(c+1)

(r, c) 좌표에서 왼쪽으로 한 칸 이동 ⇒ (r+0)(c-1)

```java

```

### 전치 행렬

대각선을 기준으로 반전 시킨 배열


```java
arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} // 3*3 행렬
int r; // 행의 좌표
int c; // 열의 좌표

for r from 0 to 2
	for c from 0 to 2
		if (i < j)
			swap(arr[i][j], arr[j][i]); 
			
for r from 0 to 2
	for c from (r+1) to 2
		swap(arr[i][j], arr[j][i]); 
```

### 2차원 배열의 회전


```java
arr = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}} // 3*3 행렬
nextArr = new int [3][3];
int r; // 행의 좌표
int c; // 열의 좌표

```

## 다차원 배열

2차원 이상의 배열 선언

- 다차원 배열은 차원 수 만큼의 index를 필요로 함
- N차원 배열은 ‘(N-1)차원의 배열’의 배열

`int[][][] ThreeDimArr = new int[**3**][2][3];`  → 2행 3열의 2차원 배열 3개를 담을 수 있는 배열