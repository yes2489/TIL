# 큐

### 큐의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조
    - 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
- 선입선출 구조 (FIFO: First In First Out)

### 큐의 주요 연산

| 연산 | 기능 |
| --- | --- |
| enQueue(item) | 큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산 |
| deQueue() | 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산 |
| createQueue() | 공백 상태의 큐를 생성하는 연산 |
| isEmpty() | 큐가 공백상태인지 확인하는 연산 |
| isFull() | 큐가 포화상태인지를 확인하는 연산 |
| Qpeek() | 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산 |
- 구현
    1.  **삽입 enQueue** → 마지막 원소 뒤에 새로운 원소 삽입
    - rear 값을 하나 증가시켜 새로운 원소를 삽입 할 자리를 마련
    - 그 인덱스에 해당하는 배열 원소 Q[rear]에 item을 저장
    
    ```java
    enQueue(item) {
    	if (isFull()) print ("Queue_Full")
    	else{
    		rear <- rear + 1;
    		Q[rear] <- item;
    	}
    }
    ```
    
    1.  **삭제 deQueue** → 가장 앞에 있는 원소를 삭제하기 위해
    - front 값을 하나 증가시켜 큐에 남아있는 첫 번째 원소 이동
    - 새로운 첫 번째 원소를 리턴 함으로써 삭제와 동일한 기능 함
    
    ```java
    deQueue() {
    	if (isFull()) print ("Queue_Full")
    	else{
    		rear <- rear + 1;
    		Q[rear] <- item;
    	}
    }
    ```
    

# 선형 큐 (Linear Queue)

## 큐의 구현

### 1차원 배열을 이용한 큐

- 큐의 크기 = 배열의 크기
- front : 마지막으로 삭제된 인덱스
- rear : 저장된 마지막 원소의 인덱스

### 상태 표현

- 초기 상태 : front = rear = -1
- 공백 상태 : front = rear
- 포화 상태 : rear = n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)

### 초기 공백 큐 생성

- 크기 n인 1차원 배열 생성
- front와 rear를 -1로 초기화

## 선형 큐 이용시의 문제점

- 잘못된 포화상태 인식
    - 해결방법 1 : 매 연산이 이루어질 때 마다 배열의 앞부분으로 모두 이동시킴
        - 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐
        - 배열 대신 연결 리스트 사용
    - 해결방법 2 : 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용
        - N이 되는 순간 0으로 이동 ⇒ 모듈러 연산 사용 `i = (i+1)%N`
        - 포화 상태와 공백 상태 구분이 어렵다는 단점이 있음

# 큐의 활용

## Buffer

- 버퍼
    - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역
    - 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미
- 버퍼의 자료 구조
    - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용
    - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용 됨

# 원형 큐

### 초기 공백상태

front = rear = 0;

### Index의 순환

- front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후,아 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
- 이를 위해 나머지 연산자 mod(%)를 사용함

### front 변수

- 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
    
    공백상태 `front == rear` 
    
    포화상태 `(배열크기+front-rear)%배열크기  == 1` 
    

### 삽입 위치 및 삭제 위치

|  | 삽입 위치 | 삭제 위치 |
| --- | --- | --- |
| 선형큐 | rear = rear +1 | front = front+1 |
| 원형큐 | rear = (rear + 1) mod n | front = (front + 1) mod n |

### 초기 공백 큐 설정

- 크기 n인 1차원 배열 생성
- front와 rear을 0으로 초기화

# 우선순위 큐

### 우선순위 큐의 특성

- 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨

### 우선순위 큐의 적용분야

- 시뮬레이션 시스템
- 네트워크 트래픽 제어
- 운영체제의 테스크 스케줄링

### 우선순위 큐의 구현

- 배열을 이용한 우선순위 큐
- 리스트를 이용한 우선순위 큐

### 우선순위 큐의 기본 연산


### 배열을 이용하여 우선순위 큐 구현

- 배열을 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨

### 문제점

- 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함
- 이에 소요되는 시간이나 메모리 낭비가 큼

# 삽입 정렬(Insertion Sort)

자료 배열의 모든 원소들을 앞에서부터 차례대로 이미 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성

### 정렬 과정

- 정렬할 자료를 두 개의 부분집합 S와 U로 가정
    - 부분 집합 S(Sorted) : 정렬된 앞부분의 원소들
    - 부분 집합 U(Unsorted) : 아직 정렬되지 않은 나머지 원소들
- U의 원소를 하나씩 꺼내서 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
- 삽입 정렬을 반복하면서 S의 원소는 하나씩 늘리고 U의 원소는 하나씩 감소
- 부분 집합 U가 공집합이 되면 삽입 정렬이 완성

```java
int[] arr = new int[] {69, 10, 30, 2, 16, 8, 31, 22};

// i : 정렬되지 않은 집합의 첫번째 원소
for (int i = 1; i < arr.length; i++){
		int data = arr[i];
	// 정렬된 집합의 뒤에서부터 비교하여 위치 찾아주기
		int j;
		for (j = i-1; j >= 0 && arr[j] > data; j--}
				arr[j + 1] = arr[j]; 
		}
		arr[j + 1] = data; 
}
```

### 시간복잡도

O(n²) ← 데이터 위치 하나 찾는데 O(n) ← N번 반복

### 알고리즘 특성 비교

| 알고리즘 | 평균수행시간 | 최악수행시간 | 알고리즘기법 | 비고 |
| --- | --- | --- | --- | --- |
| 버블 | O(n²) | O(n²) | 비교와 교환 | 코딩이 가장 손쉬움 |
| 선택 | O(n²) | O(n²) | 비교와 교환 | 교환의 회수가 버블, 삽입정렬보다 작음 |
| 카운팅 | O(n+k) | O(n+k) | 비교환 방식 | n이 비교적 작을때만 가능 |
| 삽입 | O(n²) | O(n²) | 비교와 교환 | n의 개수가 작을때 효과적 |
| 병합 | O(n log n) | O(n log n) | 분할 정복 | 연결리스트의 경우 가장 효율적인 방식 |
| 퀵 | O(n log n) | O(n²) | 분할 정복 | 최악의 경우 O(n²) 이지만 평균적으로는 가장 빠름 |